# 평가 표현식 
 - eval() : 문자열을 JS 코드로 해석하고, 이를 평가한 값을 출력한다.
 - 함수면서 연산자이다.
  - 원래 함수로 정의되었으나, 이후 언어 설계자와 인터프리터 제작자들이 eval()에 많은 제한을 두면서 연산자처럼 만들었다.
  - eval이 예약어도 아니어서 위험성이 더 크다.
 - eval()이 평가하는 코드를 분석할 수 없기 때문에 대개 인터프리터는 eval()을 호출하는 참수를 안전하게 최적화할 수 없다.
  - eval() 은 지역변수를 변경할 수 있으므로, JS 최적화에 문제가 되었다.
  - 따라서 eval()을 호출하는 함수에 대해 인터프리터는 최소한의 최적화만 수행한다.

## eval()
```
eval("function f() { return x+1; }")
```
 - 하나의 전달인자를 갖는다.
  - 문자열이 아닌 전달인자
   - 단순히 넘긴 값을 반환한다.
  - 문자열 전달인자
   - 문자열을 JS 코드로 해석 시도
    - 해석에 실패하면 SyntaxError
    - 성공하면 코드에 포함된 마지막 표현식 또는 구문의 값을 반환
     - 값이 없다면 undefined
    - 평가 도중 예외가 발생한다면 해당 예외는 eval()을 호출한 부분에서 전파된다.
 - 반드시 독자적으로 의미를 갖는 코드를 인자로 넘겨야 한다.
  - eval('return;') 과 같은 값은 아무 의미가 없다.
 - eval()이 호출되는 시점의 코드의 변수 환경을 사용한다.
  - eval이 지역 변수의 값을 사용하거나 추가, 변경할 수 있다.
 - 반드시 독자적으로 의미를 갖는 코드를 인자로 넘겨야 한다.
  - 

## 전역 eval()
 - eval의 별칭(alias)을 정의하고 다른 이름으로 호출한다면 대부분의 구현체는 인자로 전달된 문자열을 최상위 레벨 전역코드인 것처럼 평가한다.
 - 평가되는 코드는 새 전역 변수/함수를 선언하고, 전역 변수를 수정한다.
 - 그러나 지역 변수의 접근은 불가능하다.
  - 인터프리터가 지역 코드를 최적화할 때 영향이 가지 않도록 한다.
 - direct eval
  - eval이라는 이름으로 eval() 함수를 호출하는 것
  - 직접 호출 시에는 eval()을 호출하는 문맥의 변수환경을 사용한다.
 - IE 에서의 eval
  - eval()을 alias로 호출해도 전역으로 수행되지 않고, EvalError 예외도 발생하지 않는다.
  - 대신 execScript()라는 전역변수가 전역 eval()처럼 동작한다.
   - 단, 항상 null을 반환한다.



## 엄격 모드의 eval()
 - eval()의 동작뿐만 아니라, eval 을 식별자로 사용하는 것도 제한된다.
 - eval()은 private 변수 환경을 갖는 지역 eval로 실행된다.
  - 기존에 선언된 지역 변수값에 접근가능하나, 새로운 변수나 함수를 정의할 수는 없다.
 - eval을 예약어처럼 사용한다.
  - 연산자처럼 사용하거나, eval()을 새로운 값으로 덮어쓸 수도 있다.
  - 다른 변수의 이름, 인자로 eval을 사용할 수 없다.

