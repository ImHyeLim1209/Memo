# use strict
 - ECMA 5에서 처음 소개된 지시어. 문장에 가까운 특성을 가진다.
   - 지시어: 작은 따옴표 혹은 큰 따옴표로 둘러싸인 특정 문자열 리터럴로 구성된 표현문
 - use strict 다음에 오는 코드들은 엄격 모드를 따른다.
  - eval()의 경우 eval을 호출하는 코드가 엄격 모드를 따르거나, 전달된 코드 몸체에 use strict가 있다면 엄격 모드로 처리된다.
 - 엄격 모드란 언어의 일부 기능이 제한된 부분집합이다.

## use strict 지시어 vs 일반 문장
 - use strict는 어떤 JS 키워드도 포함하지 않는다.
 - use strict는 스크립트의 시작 부분이나 함수 몸체의 시작 부분에만 올 수 있으며, 다른 실제 실행문 앞에 오기만 하면 된다.
  - 반드시 첫 문장일 필요는 없다.

## 엄격 모드
 - with는 엄격모드에서 사용할 수 없다.
 - 엄격모드에서 모든 변수는 반드시 선언되어야 한다.
   - 선언되지 않은 변수나 함수, 함수 인자, catch 절인자, 전역 객ㅇ체 프로퍼티에 값을 할당할 경우 Reference Error
     - 표준 모드에서는 전역 객체에 새 프로퍼티가 묵시적으로 선언된다.
 - 함수로 호출된 함수의 this 값은 undefined가 된다. 
   - 표준 모드에서는 전역 객체가 된다.
   - 표준 모드에서는 call(), apply()의 경우 첫 번째 인자가 null, undefined라면 전역으로 대체되고, 객체가 아닌 값은 객체로 변하나, 엄격 모드에서는 그대로 사용된다.
 - 엄격 모드에서 writable 속성이 없는 프로퍼티에 값을 할당하거나, 확장할 수 없는 객체에 새 프로퍼티를 추가하려고 하면 TypeError가 발생한다.
 - 엄격 모드에서 eval()의 인자로 전달된 코드는 eval() 호출자의 스코프 안에 변수, 함수를 선언할 수 없다.
 - 엄격 모드에서 arguments 객체는 함수에 전달된 값의 정적 사본을 갖고 있다.
   - 표준 모드에서는 동일한 값을 참조한다.
 - 엄격 모드에서 delete 다음에 변수나 함수, 함수 전달인자와 같이 부적합한 식별자가 올 경우 SyntaxError
   - 표준 모드에서는 delete가 아무 동작 하지 않고, false로 평가된다.
 - 엄격 모드에서 변경할 수 없는 프로퍼티를 지우려고 하면 TypeErorr가 발생한다.
   - 표준 모드에서는 이런 시도는 실패되고, 표현식의 값이 false 로 평가된다.
 - 엄격 모드에서 객체 리터럴에 같은 이름의 프로퍼티가 중복될 경우 문법 에러가 발생한다.
 - 엄격 모드에서 함수 선언에 같은 이름 인자가 중복되면 문법 에러가 발생한다.
 - 엄격 모드에서 8진수 리터럴을 사용할 수 없다.
 - 엄격 모드에서 식별자 eval, arguments는 키워드로 취급되고, 값을 변경, 할당, 선언할 수 없으며, 함수 이름이나 함수 전달인자 이름으로 사용할 수 없고, catch블록에서 사용할 수 없다.
 - 엄격 모드에서 호출 스택을 살펴보는 기능이 제한된다.
  - argument.caller, arguments.callee 는 TypeError를 발생시킨다.
  - 엄격 모드에도 해당 프로퍼티가 있긴 하지만 읽으려고 하면 에러가 발생한다.
