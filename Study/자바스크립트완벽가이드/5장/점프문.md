# 점프문
 - JS 인터프리터가 점프문을 만나면 코드 내의 특정 위치로 건너뛴다.

## 레이블
```
// while에 레이블을 붙이고 continue에서 레이블을 사용한 경우
mainloop: while(token!=null){
  // 코드...
  continue mainloop; // 주어진 mainloop의 다음 반복으로 건너뛴다.
  // 코드
}
```
 - 어떤 문장이라도 그 앞에 식별자 이름과 콜론을 넣어 레이블을 붙일 수 있다.
 - 어떤 문장에 레이블을 붙이면 프로그램의 다른 곳에서 그 문장을 참고할 수 있는 이름이 생긴다.
 - 예약어를 제외한 모든 적법한 JS 식별자는 레이블이 될 수 있다.
 - 레이블이 속한 네임스페이스는 변수나 함수의 이름 공간과는 별도이다.
  - 변수나 함수 이름과 같은 식별자를 레이블로 사용할 수 있다.
 - 문장 레이블은 레이블이 적용될 문장과 그 하위 문장들에게만 유용하다.
 - 어떤 문장은 해당 문장을 포함하는 문장과 같은 레이블을 가질 수 없다.
  - 두 문장 사이에 포함 관계가 없으면, 두 문장은 같은 레이블을 사용할 수 있다.
 - 이미 레이블이 붙은 문장에도 레이블을 여러 개 붙일 수 있다.
 - 함수 선언문에 사용 불가능하며, 함수 내부에서만 레이블을 사용할 수 있다.

## break
 ```
 break;
 
 break labelname;
 
 ```
 - break문을 사용하면 break문을 감싸고 있는 가장 안쪽의 루프 혹은 switch 문에서 즉시 빠져 나온다.
 - break 뒤에도 레이블이 따라올 수 있다.
  - 해당 레이블이 붙은 문장 블록의 끝으로 이동하면서 종료
  - 해당 레이블이 붙은 문장 블록이 없다면 오류
  - break + 레이블인 경우, 해당 레이블이 붙은 문장이 꼭 루프나 switch문일 필요는 없다.
  - break와 레이블 사이는 줄바꿈이 허용되지 않는다. (자동으로 세미콜론이 삽입된다)
  - 중첩 루프나 switch에서 빠져나올 위치가 가장 안쪽 문장이 아닌 경우 사용된다.
 - break문은 레이블 사용 여부와 관계없이 함수 영역 바깥으로 제어권을 전달할 수 없다.

## continue
 ```
 continue;
 
 continue labelname;
 
 ```
 - break와 유사하나, 루프를 빠져나오지 않고 새로운 반복을 시작한다.
 - continue 뒤에도 레이블이 따라올 수 있다.
 - 항상 루프의 몸체 내부에서 사용해야 하며, 이외의 부분에서 사용하면 문법 에러
 - 루프 종류에 따른 동작
  - while
   - 루프의 시작부분으로 돌아가 지정된 표현식을 다시 테스트한다. 결과가 true라면 루프 몸체 처음부터 다시 실행한다.
  - do-while
   - 루프의 끝부분까지 건너뛰고, 루프 조건을 다시 테스트하여 결과가 true 라면 몸체의 처음부터 다시 실행한다.
  - for
   - 루프의 처음으로 돌아가 증감 표현식을 평가한 후 지정된 표현식을 테스트하여 다음 반복을 수행할지 여부를 판단한다.
   - while과 달리 증감 표현식을 우선 평가하는 동작을 수행하므로, while루프만을 사용하여 for 루프를 완벽하게 흉내낼 수 없다.
  - for-in
   - 루프의 처음으로 돌아가 다음 차례의 프로퍼티 이름을 지정된 변수에 할당 후 루프를 다시 시작한다.

## return
 - 함수 호출 표현식의 값 즉, 함수에서 반환하는 값을 지정하는 데 사용한다.
 - 함수 몸체 내부에서만 사용 가능하다.
  - 다른 곳에서 사용하면 문법 오류
 - return문이 실행되면 표현식이 평가되어 그 결과가 함수의 값으로 반환된다.
 - 함수 내에 return이 없다면 함수 호출은 단지 함수 몸체 끝에 도달할 때까지 모든 구문을 차례로 실행하고, 호출한 지점으로 돌아간다.
  - 함수 호출 표현식의 값은 undefined가 된다.
 - 함수 몸체의 어느 곳에서나 사용 가능하다.
 - return 뒤에 자동으로 세미콜론이 삽입되므로 return과 표현식 사이에 줄바꿈을 해서는 안된다.

## throw
```
throw 표현식;
```
 - 예외를 발생시킨다.
  - 예외: 예외적인 상황이나 에러가 발생했음을 가리키는 신호
  - 예외를 잡는 것: 해당 예외에서 회복하기위해 무언가 필요하거나 적절한 행동을 취하여 예외를 처리한다.
   - 예외는 try-catch-finally로 처리할 수 있다.
 - 표현식은 어떤 타입도 가능하므로, 에러코드를 의미하는 숫자, 에러 메시지를 의미하는 문자열, 에러객체 등을 던질 수 있다.
 - 에러 객체
   - name: 에러의 종류를 의미하는 프로퍼티
   - message: Error 클래스 생성자 함수에 넘기는 문자열을 담은 프로퍼티
 - 에러가 발생하면 JS 인터프리터는 정상적인 프로그램 실행을 즉시 중단하고 가장 가까운 예외 처리기로 넘긴다.
   - 예외처리기: catch
 - 예외를 발생시킨 코드 블록이 catch절과 연결되어 있지 않으면, 인터프리터는 바로 상위 단계를 감싸고 있는 코드 블록에 연결된 예외가 있는지 확인한다.
 - 해당 함수 내에서 예외를 처리할 try-catch가 없다면 함수를 호출했던 블록으로 그 예외가 전파되어 올라간다.
   - JS의 예외는 호출스택을 따라 전파된다.
   - 예외 처리기가 호출스택을 따라서 끝까지 전파되어도 찾지 못한 경우 해당 예외는 에러취급되고, 사용자에게 보고된다.


## try-catch-finally
```
// for 루프 흉내내기
// for(초기화;테스트;증가) 몸체;
// 완전히 흉내내는 것은 불가능하다. break가 몸체에 포함된 경우, finally 에서 증감 표현식이 한 번 더 실행되기 

초기화;
while(테스트){
 try{몸체;}
 finally{증감;}
}
```
 - 종류
   - try: 예외가 발생할 수 있는 코드 블록을 정의
   - catch: try 블록에서 예외가 발생할 경우 호출되는 문장 블록
   - finally: try 블록에서의 예외 발생 여부와 관계없이 try문이 종료된 후에 실행이 보장되어야 하는 뒷정리용 코드가 담긴 블록
    - 예외 발생 시 catch 블록을 수행한 후 finally 블록으로 넘어온다.
    - 예외 발생했는데 catch가 없었다면 finally 블록을 수행한 후 가장 가까운 catch 블록으로 이동한다.
    - finally 안에서도 return, continue, break, throw 및 예외 발생 가능성이 있는 메서드를 호출할 수 있다.
     - 이 경우 기존 예정된 모든 점프를 취소하고 새로운 점프를 실행한다.
      - finally에서 예외가 발생하면 기존에 던져질 예정이던 예외 대신 새로운 예외가 던져진다.
 - catch, finally는 생략 가능하다
 - 절에 하나의 문장만 있더라도 중괄호는 생략할 수 없다.
 - try 종료 조건
   - try 블록 끝에 도달한 경우
   - break, continue, return
   - catch에서 처리
   - 예외가 catch에서 안 잡히고 퍼져 나가는 경우
 - catch의 인자
   - 예외와 관련된 값이 catch의 전달 인자에 할당된다.
   - catch 블록 몸체 내부에만 존재하는 지역변수이다. 
